### 题目背景

Ray 乐忠于旅游，这次他来到了 T 城。T 城是一个水上城市，一共有 *n* 个景点，有些景点之间会用一座桥连接。为了方便游客到达每个景点但又为了节约成本，T 城的任意两个景点之间有且只有一条路径。换句话说， T 城中只有 *n*−1 座桥。

Ray 发现，有些桥上可以看到美丽的景色，让人心情愉悦，但有些桥狭窄泥泞，令人烦躁。于是，他给每座桥定义一个愉悦度 *w*，也就是说，Ray 经过这座桥会增加 *w* 的愉悦度，这或许是正的也可能是负的。有时，Ray 看待同一座桥的心情也会发生改变。

现在，Ray 想让你帮他计算从 *u* 景点到 *v* 景点能获得的总愉悦度。有时，他还想知道某段路上最美丽的桥所提供的最大愉悦度，或是某段路上最糟糕的一座桥提供的最低愉悦度。

### 题目描述

给定一棵 n*n* 个节点的树，边带权，编号 $0 \sim n−1$，需要支持五种操作：

- `C i w` 将输入的第 *i* 条边权值改为 *w*
- `N u v` 将 *u*,*v* 节点之间的边权都变为相反数
- `SUM u v` 询问 *u*,*v* 节点之间边权和
- `MAX u v` 询问 *u*,*v* 节点之间边权最大值
- `MIN u v` 询问 *u*,*v* 节点之间边权最小值

保证任意时刻所有边的权值都在 $[-1000,1000]$ 内。

### 输入格式

第一行一个正整数 *n*，表示节点个数。
接下来 *n*−1 行，每行三个整数 *u*,*v*,*w*，表示 *u*,*v* 之间有一条权值为 *w* 的边，描述这棵树。
然后一行一个正整数 *m*，表示操作数。
接下来 *m* 行，每行表示一个操作。

### 输出格式

对于每一个询问操作，输出一行一个整数表示答案。

### 说明/提示

对于 100% 的数据，$1\le n,m \le2\times 10^5$。

---

### 树链剖分+边带权问题

n 个点， n-1 条边，显然是一棵树，需要对树上任意一条路径进行边权之和查询和修改，同时维护路径上的边权最大值和最小值

将这棵树剖分成若干条重链，对每一条链用线段树进行维护，值得一提的是，题目中要求边带权，所以需要考虑如何吧边权转化为点权。

提供一种方案，一条边的边权存在儿子节点上

在对路径（u，v）合并时，要注意避开他们的 LCA，因为该点存的值不在（u, v）上

```c++
change(1, id[x], id[x]+size[x]-1, 1);
```

---

### 代码

```c++
#include<iostream>
#include<cstdio>
#include<cmath>
using namespace std;
const int N = 2*1e5+10;
int n, m;
int flag;
int a[N], b[N];
int ans_sum, ans_min, ans_max;

int head[N], tot=1;
struct node{
	int next, ver, val;
}e[N*2];
void add(int x, int y, int z) {
	e[++tot].next = head[x];
	e[tot].ver = y;
	e[tot].val = z;
	head[x] = tot;
}

int de[N], fa[N], size[N], son[N], top[N], id[N], re[N], dfn;
void dfs1(int x, int f) {
	fa[x] = f;
	de[x] = de[f]+1;
	size[x] = 1;
	int max_son=0;
	for (int i = head[x]; i; i = e[i].next) {
		int y = e[i].ver, z = e[i].val;
		if (y == fa[x]) continue;
		b[y] = z;
		dfs1(y, x);
		size[x] += size[y];
		if (size[y] > max_son) max_son = size[y], son[x] = y;
	}
}
void dfs2(int x, int tp) {
	top[x] = tp;
	id[x] = ++dfn;
	re[dfn] = x;
	a[dfn] = b[x];
	if (!son[x]) return;
	dfs2(son[x], tp);
	for (int i = head[x]; i; i = e[i].next) {
		int y = e[i].ver;
		if (y == fa[x] || y == son[x]) continue;
		dfs2(y, y);
	}
}

struct SegmentTree {
	int l, r;
	long long sum;
	int imin, imax, tag;
	#define l(x) tt[x].l
	#define r(x) tt[x].r
	#define sum(x) tt[x].sum
	#define tag(x) tt[x].tag
	#define mn(x) tt[x].imin
	#define mx(x) tt[x].imax
} tt[N*4];
void build(int p, int l, int r) {
	l(p) = l, r(p) = r;
	if (l==r) { sum(p) = mn(p) = mx(p) = a[l]; return; }
	int mid = (l+r)>>1;
	build(p*2, l, mid);
	build(p*2+1, mid+1, r);
	sum(p) = sum(p*2) + sum(p*2+1);
	mn(p) = min(mn(p*2), mn(p*2+1));
	mx(p) = max(mx(p*2), mx(p*2+1));
}
void spread(int p) {
	if (tag(p)) {
		sum(p*2) *= -1;
		sum(p*2+1) *= -1;
		int tem = mn(p*2);
		mn(p*2) = -mx(p*2);
		mx(p*2) = -tem;
		tem = mn(p*2+1);
		mn(p*2+1) = -mx(p*2+1);
		mx(p*2+1) = -tem;
		tag(p*2) ^= 1;
		tag(p*2+1) ^= 1;
		tag(p) = 0;
	}
}
void change(int p, int l, int r, int d) {
	if (l <= l(p) && r >= r(p)) {
		if (d >= -1000 && d <= 1000) {
			if (l(p) == r(p))
				sum(p) = mn(p) = mx(p) = d;
		} 
		else {
			int tem = mn(p);
			mn(p) = -mx(p);
			mx(p) = -tem;
			sum(p)*=-1;
			tag(p) ^= 1;
		}
		return;
	}
	spread(p);
	int mid = (l(p)+r(p))>>1;
	if (l <= mid) change(p*2, l, r, d);
	if (r > mid) change(p*2+1, l, r, d);
	sum(p) = sum(p*2) + sum(p*2+1);
	mn(p) = min(mn(p*2), mn(p*2+1));
	mx(p) = max(mx(p*2), mx(p*2+1));
}
void ask(int p, int l, int r) {
	if (l <= l(p) && r >= r(p)) {
		ans_sum += sum(p);
		ans_min = min(ans_min, mn(p));
		ans_max = max(ans_max, mx(p));
		return;
	}
	spread(p);
	int mid = (l(p)+r(p))>>1;
	if (l <= mid) ask(p*2, l, r);
	if (r > mid) ask(p*2+1, l, r);
}

void query(int x, int y) {
	while(top[x] != top[y]) {//No de[top[x]] or de[top[y]]
		if (de[top[x]] < de[top[y]]) swap(x, y);
		ask(1, id[top[x]], id[x]);
		x = fa[top[x]];
	}
	if (de[x] > de[y]) swap(x, y);
	ask(1, id[x]+1, id[y]);
	
}
void qxg(int x, int y) {
	while(top[x] != top[y]) {//No de[top[x]] or de[top[y]]
		if (de[top[x]] < de[top[y]]) swap(x, y);
		change(1, id[top[x]], id[x], flag);
		x = fa[top[x]];
	}
		if (de[x] > de[y]) swap(x, y);
		change(1, id[x]+1, id[y], flag);
}
int main() {
	scanf("%d", &n);
	for (int i=1; i<n; i++) {
		int u, v, w;
		scanf("%d%d%d", &u, &v, &w);
		add(u, v, w);
		add(v, u, w);
	}
	dfs1(0, 0);
	dfs2(0, 0);
	build(1, 1, n);
	scanf("%d", &m);
	while (m--) {
		char op[20];
		int x, y;
		scanf("%s %d %d", op, &x, &y);
		ans_sum=0, ans_min=1e5, ans_max=-1e5, flag = 1111;
		if (op[0] == 'C') {
			int u = e[x*2].ver, v = e[x*2^1].ver;
			if (de[u] < de[v]) swap(u, v);	
			change(1, id[u], id[u], y);
			continue;
		}
		if (op[0] == 'N') {
			qxg(x, y);
			continue;
		}
		if (op[1] == 'U') {
			query(x, y);
			printf("%d\n", ans_sum);
			continue;
		}
		if (op[1] == 'A') {
			query(x, y);
			printf("%d\n", ans_max);
			continue;
		}
		if (op[1] == 'I') {
			query(x, y);
			printf("%d\n", ans_min);
			continue;
		}
	}
	return 0;
}
```
